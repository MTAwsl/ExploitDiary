<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="【逆向技巧总结】 对开源库函数的手动识别在各种逆向工程项目以及CTF竞赛题目中，很多都会用到开源库，例如LuaJIT中集成的Lua解释器，和OpenSSL、zlib等常用的库。很多库都有十分复杂的逻辑，在逆向过程中如果详细的去分析便会加大很多工作量，而且很多的逻辑会应用到数学、密码方面的知识，如果缺乏这些理论知识基本没有办法去逆向这些程序。那么这时候对于各种库函数的识别便会变得十分重要，这篇文章主">
<meta property="og:type" content="article">
<meta property="og:title" content="【逆向技巧总结】 对开源库函数的手动识别">
<meta property="og:url" content="https://awsl.rip/2021/11/24/239b3175dd5d/index.html">
<meta property="og:site_name" content="Socular 的博客">
<meta property="og:description" content="【逆向技巧总结】 对开源库函数的手动识别在各种逆向工程项目以及CTF竞赛题目中，很多都会用到开源库，例如LuaJIT中集成的Lua解释器，和OpenSSL、zlib等常用的库。很多库都有十分复杂的逻辑，在逆向过程中如果详细的去分析便会加大很多工作量，而且很多的逻辑会应用到数学、密码方面的知识，如果缺乏这些理论知识基本没有办法去逆向这些程序。那么这时候对于各种库函数的识别便会变得十分重要，这篇文章主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123114755459.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123115034078.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123202633003.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123203238717.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123202317790.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123214331866.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123215513401.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123222442025.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123224656401.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123224927864.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123225143023.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123225156811.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123225345002.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123225941028.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123225900603.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124134349062.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124134800836.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124134821051.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124134843904.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124134927746.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124135648519.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124135804530.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124135810615.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124140455829.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124140948960.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141117855.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141151415.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141332255.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141552761.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141619513.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141758474.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124141948466.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124142235941.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124142905712.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124142653055.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124142842382.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124143000881.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124143005986.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124143227220.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124144959385.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124145405407.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124145729352.png">
<meta property="og:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211124152939839.png">
<meta property="article:published_time" content="2021-11-23T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-07T14:03:23.052Z">
<meta property="article:author" content="Dominic Socular">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://awsl.rip/2021/11/24/239b3175dd5d/image-20211123114755459.png">
    
    
        
          
              <link rel="shortcut icon" href="https://www.gravatar.com/avatar/202e3e3a8e8fcefd140c1aab9b54c0d6?s=16">
          
        
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/202e3e3a8e8fcefd140c1aab9b54c0d6?s=192" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/202e3e3a8e8fcefd140c1aab9b54c0d6?s=180">
          
        
    
    <!-- title -->
    <title>【逆向技巧总结】 对开源库函数的手动识别</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

	
	<!-- FriendsLink -->
	
	
	
    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="Socular 的博客" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/01/07/42988ce3d67b/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/11/16/fdabc2439116/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://awsl.rip/2021/11/24/239b3175dd5d/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://awsl.rip/2021/11/24/239b3175dd5d/&text=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://awsl.rip/2021/11/24/239b3175dd5d/&is_video=false&description=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【逆向技巧总结】 对开源库函数的手动识别&body=Check out this article: https://awsl.rip/2021/11/24/239b3175dd5d/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://awsl.rip/2021/11/24/239b3175dd5d/&name=【逆向技巧总结】 对开源库函数的手动识别&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://awsl.rip/2021/11/24/239b3175dd5d/&t=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E9%80%86%E5%90%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E3%80%91-%E5%AF%B9%E5%BC%80%E6%BA%90%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%8B%E5%8A%A8%E8%AF%86%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">【逆向技巧总结】 对开源库函数的手动识别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90-BinDiff"><span class="toc-number">1.2.</span> <span class="toc-text">自动化分析 - BinDiff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">环境安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-SE-Development-Kit"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Java SE Development Kit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDA-Pro"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">IDA Pro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BinDiff"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">BinDiff</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%88%86%E6%9E%90-%E5%AF%B9%E7%85%A7%E6%BA%90%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">手动分析 - 对照源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%BC%80%E4%B8%89%E6%AC%A1%E6%95%B4%E6%95%B0%E7%AB%8B%E6%96%B9%E6%A0%B9%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">1.5.</span> <span class="toc-text">附录：对于开三次整数立方根的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">传统二分查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">牛顿迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%A0%B9%E5%BC%8F%E6%95%B4%E6%95%B0%E8%A7%A3%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.5.3.</span> <span class="toc-text">特殊情况：三次根式整数解二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">附件</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        【逆向技巧总结】 对开源库函数的手动识别
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Socular 的博客</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-11-23T16:00:00.000Z" itemprop="datePublished">2021-11-24</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="【逆向技巧总结】-对开源库函数的手动识别"><a href="#【逆向技巧总结】-对开源库函数的手动识别" class="headerlink" title="【逆向技巧总结】 对开源库函数的手动识别"></a>【逆向技巧总结】 对开源库函数的手动识别</h1><p>在各种逆向工程项目以及CTF竞赛题目中，很多都会用到开源库，例如LuaJIT中集成的Lua解释器，和OpenSSL、zlib等常用的库。很多库都有十分复杂的逻辑，在逆向过程中如果详细的去分析便会加大很多工作量，而且很多的逻辑会应用到数学、密码方面的知识，如果缺乏这些理论知识基本没有办法去逆向这些程序。那么这时候对于各种库函数的识别便会变得十分重要，这篇文章主要介绍两种方式对开源库函数进行识别。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先说一下大体的思路，我们既然找到了开源库，那么在程序中用到的很多函数的代码逻辑基本上和库里是相同的。也就是说，我们拿到了程序的部分源代码，但是并不知道这些源代码分别对应程序中的哪一个部分。如果我们可以找到对应的函数，就可以通过查阅开源库的源代码、函数名（符号）、开发文档去了解函数的功能。本篇文章要介绍的两种方式均是以这种思路去展开。</p>
<h2 id="自动化分析-BinDiff"><a href="#自动化分析-BinDiff" class="headerlink" title="自动化分析 - BinDiff"></a>自动化分析 - BinDiff</h2><p>BinDiff是一款用于比对IDA数据库中的函数代码相似度的自动化工具，识别出的代码相似度越高，实现相同逻辑的可能性就越大。换句话说，就是将函数名与程序中的函数体进行匹配的工具。</p>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h4 id="Java-SE-Development-Kit"><a href="#Java-SE-Development-Kit" class="headerlink" title="Java SE Development Kit"></a>Java SE Development Kit</h4><p>首先需要安装JDK，笔者这里用的是JDK 11，在Oracle的官网即可下载安装。</p>
<p>可根据需要选择相应的版本：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p>
<h4 id="IDA-Pro"><a href="#IDA-Pro" class="headerlink" title="IDA Pro"></a>IDA Pro</h4><p>BinDiff是通过IDA生成的数据库进行的匹配，IDA Pro产品需要购买才可使用，是一款十分强大的逆向工具，笔者这里使用的是IDA 7.6版本。</p>
<p>官方网站地址：<a target="_blank" rel="noopener" href="https://hex-rays.com/ida-pro/">https://hex-rays.com/ida-pro/</a></p>
<h4 id="BinDiff"><a href="#BinDiff" class="headerlink" title="BinDiff"></a>BinDiff</h4><p>官方下载地址在此，根据系统和环境的版本选择即可：<a target="_blank" rel="noopener" href="https://www.zynamics.com/software.html%E2%80%99">https://www.zynamics.com/software.html’</a></p>
<p>注意：安装过程中会让你选择IDA的路径，此时要选择你的IDA工具（ida.exe/ida64.exe）的所在目录</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>若要使用BinDiff工具，需要提供另一个idb数据库作为比对。</p>
<p>在此我们首先使用IDA打开被分析程序的数据库，然后File-&gt;BinDiff中选择要比对的idb数据库即可</p>
<p><img src="image-20211123114755459.png" alt="image-20211123114755459"></p>
<p>等待一段时间后便可以在Matched Functions中得到匹配结果。</p>
<p><img src="image-20211123115034078.png" alt="image-20211123115034078"></p>
<p>在左侧的sub_XXXX这些没有被命名的函数便可以通过这种方式找出对应的函数名。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在这里使用Defcon Final 2021 - Barb Metal举例。（题目地址：<a target="_blank" rel="noopener" href="https://github.com/o-o-overflow/dc2021f-barb-metal-public">https://github.com/o-o-overflow/dc2021f-barb-metal-public</a> ）</p>
<p>这道题使用了mrubyc库实现了一个虚拟机，并对虚拟机的代码进行了加密，题目要求在虚拟机代码中寻找漏洞得到flag。</p>
<p>在此我们只进行相关库的匹配。</p>
<p>第一步是寻找库的特征，例如OpenSSL中的字符串，编译时添加的Assertion信息等，通过这些信息定位到具体使用了哪个开源库。</p>
<p>直接在IDA中进行字符串的查找，可以得到以下结果，有很多的代码路径信息。</p>
<p><img src="image-20211123202633003.png" alt="image-20211123202633003"></p>
<p><img src="image-20211123203238717.png" alt="image-20211123203238717"></p>
<p>直接进入Google搜索LibTomMath、mrubyc，以及代码的路径信息。</p>
<p>得到以下三个开源库，均托管在Github：</p>
<ul>
<li>LibTomMath(<a target="_blank" rel="noopener" href="https://github.com/libtom/libtommath">https://github.com/libtom/libtommath</a>)</li>
<li>LibTomCrypt(<a target="_blank" rel="noopener" href="https://github.com/libtom/libtomcrypt">https://github.com/libtom/libtomcrypt</a>)</li>
<li>mrubyc(<a target="_blank" rel="noopener" href="https://github.com/mrubyc/mrubyc">https://github.com/mrubyc/mrubyc</a>)</li>
</ul>
<p>第二步，将开源库编译成相同架构的二进制库文件，这里是Linux下的x86架构程序</p>
<p><img src="image-20211123202317790.png" alt="image-20211123202317790"></p>
<p>这里要注意的有两点，第一点是一定要在32位环境下编译（如果在64位环境下需要在CFLAG上加-m32参数），因为我们要逆向的文件是32位的。第二点是，如果要在比较方便的情况下使用BinDiff，就需要将静态链接库（ar）转化为动态链接库（so），因为静态链接库实质是一个压缩包，里面有很多编译后的库文件，那么每个库文件就需要一个idb去存储它的代码信息。而动态链接库只需要一个idb即可，因此我们尽量使用动态链接库的方式生成二进制文件。</p>
<p>修改Makefile文件，以mrubyc为例</p>
<p><img src="image-20211123214331866.png" alt="image-20211123214331866"><em>修改前</em></p>
<p><img src="image-20211123215513401.png" alt="image-20211123215513401"><em>修改后</em></p>
<p>这样make后的结果便是libmrubyc.so这一个动态链接库文件</p>
<p>以此类推，继续编译LibTomCrypt和LibTomMath库，最终我们得到了三个so文件</p>
<p><img src="image-20211123222442025.png" alt="image-20211123222442025"></p>
<p>分别导入IDA生成对应的idb，使用BinDiff选中进行分析</p>
<p><img src="image-20211123224656401.png" alt="image-20211123224656401"></p>
<p>但是对于libTomCrypt和libTomMath，BinDiff便有些鸡肋了。</p>
<p><img src="image-20211123224927864.png" alt="image-20211123224927864"></p>
<p>但是通过BinDiff，我们的分析便会变得十分简单，例如如下函数</p>
<p><img src="image-20211123225143023.png" alt="image-20211123225143023"></p>
<p><img src="image-20211123225156811.png" alt="image-20211123225156811"></p>
<p>同时mrubyc的opcode也一清二楚</p>
<p><img src="image-20211123225345002.png" alt="image-20211123225345002"></p>
<p>对于BinDiff就介绍这么多，这款自动化工具十分好用，对于各种开源库的识别十分有帮助，当然，选择开源库的版本也十分重要，最好是要让所有库的版本都和待逆向程序的版本相同，这样才能提高匹配度。</p>
<blockquote>
<p>当时做这道题的时候还没有学会使用BinDiff，而且通宵比赛，我的体力也跟不上，几个小时只能勉强逆向出这一堆opcode，后面和源码一比较发现什么都没变，也就是说我这几个小时什么都没逆出来。。。</p>
<p>后来pizza醒了，把idb传到队伍里之后趴在桌子上歇了一会儿，估计pizza看到我这idb要气疯了（逃</p>
</blockquote>
<h2 id="手动分析-对照源码"><a href="#手动分析-对照源码" class="headerlink" title="手动分析 - 对照源码"></a>手动分析 - 对照源码</h2><p>如果BinDiff这种自动化工具不是很有效的匹配函数，那么我们只能通过手动的对照源代码来分析每个函数的作用了。</p>
<p>拿刚刚的LibTom举例，我们可以得到的信息有源码所在目录和文件，甚至是本行的代码或是Assertion信息，有的函数说不定直接把函数名信息写在了里面。通过这些信息去定位源代码的位置函数，可以用来匹配函数符号。</p>
<p><img src="image-20211123225941028.png" alt="image-20211123225941028"><em>源代码信息</em></p>
<p><img src="image-20211123225900603.png" alt="image-20211123225900603"><em>直接给出函数名</em></p>
<p>不过这种情况在CTF的逆向中比较少见（除非题目侧重点不在逆向上面），这时候程序本身的逻辑便会显得十分重要，不论怎么改变函数名、源代码，函数的逻辑不会产生变化。而通过人工直接分析函数逻辑，便可以在信息不足的情况下定位函数。接下来要演示通过函数本身的特性手动分析的方法。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>本题基本没有任何的信息可供查找（出题人甚至将函数本身可以追溯到源代码的某些特性删除了），那么我们首先从main函数入手。</p>
<p><img src="image-20211124134349062.png" alt="image-20211124134349062"></p>
<p>可以大概浏览伪代码，程序首先打印出key，然后将data.txt加密存入enc.dat中，再用字符串FLAG分割，写入经过sub_E9F和sub_C06E变换的key。</p>
<p>但是进入任何一个函数，逻辑都十分复杂，根本没有办法看懂。</p>
<p>因此我们从可以看到的常量值下手，首先从上往下看，首先进入sub_B91F，里面有两块数据，但很遗憾经过搜索里面的数据都没有信息表明是哪个算法。</p>
<p><img src="image-20211124134800836.png" alt="image-20211124134800836"></p>
<p>那么进入sub_B7BC，可以看到简单的逻辑，再进入sub_B714看下它进行了什么变换</p>
<p><img src="image-20211124134821051.png" alt="image-20211124134821051"></p>
<p><img src="image-20211124134843904.png" alt="image-20211124134843904"></p>
<p>将a1类型修改为_DWORD*，因为根据前文分析a1是一个整型数组。</p>
<p><img src="image-20211124134927746.png" alt="image-20211124134927746"></p>
<p>0x312 0x212 0x12 0x112这些值看起来很特殊，那么我们搜索这些值尝试一下。</p>
<p>找到了加密算法来源，是任天堂DS的算法。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/RocketRobz/NTR_Launcher_3D/blob/master/twlnand-side/BootLoader/source/encryption.c">https://github.com/RocketRobz/NTR_Launcher_3D/blob/master/twlnand-side/BootLoader/source/encryption.c</a></p>
<p>根据对照源代码，可以得到以下函数映射</p>
<blockquote>
<p>sub_B91F -&gt; apply_keycode </p>
<p>sub_B7BC -&gt; crypt_64bit_up</p>
</blockquote>
<p>而上面那两个数据集，如果仔细分析源代码和该程序的逻辑后发现，无非是将自身的key写入了一个sbox中，后面的一大堆数据甚至根本都没有用到，这两个数据集实际上是对我们逆向的一个干扰。</p>
<p>退回到main函数，找到加密逻辑sub_CB0</p>
<p><img src="image-20211124135648519.png" alt="image-20211124135648519"></p>
<p>sub_B86E是什么实际上已经没有任何意义了，因为v15是我们加密后的数据，而sub_B86E对其一点影响都没有，不过根据逻辑对照后这个函数其实是将刚刚加密的数据解密回去。。。不知道出题人为什么要加入这个函数。</p>
<p>下图两个函数都是将unsigned int四个字节的大端序和小端序进行交换，实际上就是上面源代码的bswap_32bit函数逻辑。</p>
<p><img src="image-20211124135804530.png" alt="image-20211124135804530"></p>
<p><img src="image-20211124135810615.png" alt="image-20211124135810615"></p>
<p>接下来思路就十分明显了，首先想办法解密key，再将生成的sbox Dump下来，再进行解密即可。</p>
<p>解密逻辑如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crypt_64bit_down</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x11</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        z = sbox[i] ^ x</span><br><span class="line">        x = sbox[<span class="number">0x012</span> + ((z&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>)];</span><br><span class="line">        x = sbox[<span class="number">0x112</span> + ((z&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)] + x;</span><br><span class="line">        x = sbox[<span class="number">0x212</span> + ((z&gt;&gt; <span class="number">8</span>)&amp;<span class="number">0xff</span>)] ^ x;</span><br><span class="line">        x = sbox[<span class="number">0x312</span> + ((z&gt;&gt; <span class="number">0</span>)&amp;<span class="number">0xff</span>)] + x;</span><br><span class="line">        x = y ^ x</span><br><span class="line">        y = z</span><br><span class="line">    x = x ^ sbox[<span class="number">1</span>]</span><br><span class="line">    y = y ^ sbox[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> (x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byteswap32</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span> | (a &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF0000</span> | (a &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span> | (a &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encbuf), <span class="number">2</span>):</span><br><span class="line">    a, b = encbuf[i], encbuf[i+<span class="number">1</span>]</span><br><span class="line">    a, b = crypt_64bit_down(byteswap32(a), byteswap32(b))</span><br><span class="line">    a = byteswap32(a)</span><br><span class="line">    b = byteswap32(b)</span><br><span class="line">    encbuf[i: i+<span class="number">2</span>] = [a, b]</span><br></pre></td></tr></table></figure>

<p>接下来回到main函数，跟踪sub_2200-&gt;sub_1CB0，这个函数很大，不过有一些关键变量可以让我们进行搜索</p>
<p><img src="image-20211124140455829.png" alt="image-20211124140455829"></p>
<p>放入Google搜索得到MIRACL库的结果，源码在此<a target="_blank" rel="noopener" href="https://github.com/miracl/MIRACL/blob/master/source/mrcore.c">https://github.com/miracl/MIRACL/blob/master/source/mrcore.c</a></p>
<p>我还找到了看雪上不错的一篇文章( <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-222568.htm">https://bbs.pediy.com/thread-222568.htm</a> )，专门讲了如何识别MIRACL的库函数，只可惜这道题把文章中说到的函数的特征去掉了，所以没办法通过这篇文章的思路进行识别了。</p>
<p>那么我们直接编译好拖进BinDiff，不过很遗憾，识别率低的出奇，根本没办法参考</p>
<p><img src="image-20211124140948960.png" alt="image-20211124140948960"></p>
<p>不过我们编译好的so文件也不是没有用处的，用IDA打开，第一件事搜索关键值，得到我们函数的名称为mirsys_basic，接下来对照符号表，将so文件对应的函数填入我们逆向的程序中</p>
<p><img src="image-20211124141117855.png" alt="image-20211124141117855"></p>
<p><img src="image-20211124141151415.png" alt="image-20211124141151415"><em>我们编译好的so文件</em></p>
<p><img src="image-20211124141332255.png" alt="image-20211124141332255"><em>需要逆向的程序</em></p>
<p>接下来跟进每个函数中，根据判断条件、调用函数等函数逻辑继续给函数重命名，例如这个函数用到了0x80000000这个值，直接搜索，跟进每一个函数自己看代码相似度</p>
<p><img src="image-20211124141552761.png" alt="image-20211124141552761"></p>
<p><img src="image-20211124141619513.png" alt="image-20211124141619513"></p>
<p><img src="image-20211124141758474.png" alt="image-20211124141758474"></p>
<p>猜测其为convert函数，接下来以此类推，用X交叉引用，查到这两个函数很相似，尤其是那个调用参数1</p>
<p><img src="image-20211124141948466.png" alt="image-20211124141948466"></p>
<p>继续向下看，基本可以断定这两个函数完全一样，命名为mr_jsf，然后将copy add sub subdiv mr_addbit premult等函数也识别了出来，以此类推继续识别到cinstr函数</p>
<p><img src="image-20211124142235941.png" alt="image-20211124142235941"></p>
<p>这里有一个小技巧，我们既然识别到了mr_berror函数，这个函数在很多函数中进行了调用，但是调用次数很少，都在1-5次之间，那么我们可以用交叉引用判断它再程序中调用的次数和位置，再看它的参数（例如此处的3）即可判断这个函数到底是什么名字。</p>
<p>例如很复杂的sub_6370函数，调用了两次，值分别为10和7</p>
<p><img src="image-20211124142905712.png" alt="image-20211124142905712"></p>
<p>找调用两次并且参数均为10和7的函数</p>
<p><img src="image-20211124142653055.png" alt="image-20211124142653055"></p>
<p><img src="image-20211124142842382.png" alt="image-20211124142842382"></p>
<p>通过手动分析基本可以断定其为powmod函数。</p>
<p>以此类推，分别恢复符号。</p>
<p><img src="image-20211124143000881.png" alt="image-20211124143000881"></p>
<p><img src="image-20211124143005986.png" alt="image-20211124143005986"></p>
<p>那么加密的逻辑就是以下结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encrypted = powmod(key, <span class="number">3</span>, <span class="number">0x5AD19C2F71693D482E2B6A2425CDCDDFB100A68C6E488F5359</span>)</span><br></pre></td></tr></table></figure>

<p>很简单的逻辑，接下来继续回到main函数的sub_C06E函数</p>
<p><img src="image-20211124143227220.png" alt="image-20211124143227220"></p>
<p>经过搜索和识别很明显是base58算法，字典被改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9876432*Flag&#123;n0T-EA5y=to+f1Nd&#125;BCDGHJKLMPQRSUVWXYZbcehijkmp</span><br></pre></td></tr></table></figure>

<p>那么一下代码即可得到key的值，开三次整数平方根即可（在此使用gmpy2工具，<a href="#%E9%99%84%E5%BD%95%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%BC%80%E4%B8%89%E6%AC%A1%E6%95%B4%E6%95%B0%E7%AB%8B%E6%96%B9%E6%A0%B9%E7%9A%84%E6%80%9D%E8%80%83">在文章的附录中对此有展开说明</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;9876432*Flag&#123;n0T-EA5y=to+f1Nd&#125;BCDGHJKLMPQRSUVWXYZbcehijkmp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./enc.dat.bak&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buf = f.read()</span><br><span class="line"></span><br><span class="line">encrypted, key = buf.split(<span class="string">b&quot;FLAG&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = base58.b58decode(key.translate(<span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Key: &quot;</span> + <span class="built_in">int</span>(gmpy2.iroot(<span class="built_in">int</span>.from_bytes(key, <span class="string">&quot;big&quot;</span>))[<span class="number">0</span>]).to_bytes(<span class="number">8</span>, <span class="string">&quot;big&quot;</span>).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Key: N5f0cuS_</span></span><br></pre></td></tr></table></figure>

<p>通过调试，将key的值更改掉，然后待程序生成好sbox之后去将其dump下来，得到sbox.bin</p>
<p>接下来就是笔者的完整解题脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base58</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;9876432*Flag&#123;n0T-EA5y=to+f1Nd&#125;BCDGHJKLMPQRSUVWXYZbcehijkmp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./enc.dat.bak&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buf = f.read()</span><br><span class="line"></span><br><span class="line">encrypted, key = buf.split(<span class="string">b&quot;FLAG&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = base58.b58decode(key.translate(<span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Key: &quot;</span> + <span class="built_in">int</span>(gmpy2.iroot(<span class="built_in">int</span>.from_bytes(key, <span class="string">&quot;big&quot;</span>))[<span class="number">0</span>]).to_bytes(<span class="number">8</span>, <span class="string">&quot;big&quot;</span>).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Key: N5f0cuS_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./sbox.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buf = f.read()</span><br><span class="line"></span><br><span class="line">it = struct.iter_unpack(<span class="string">&quot;&lt;I&quot;</span>, buf)</span><br><span class="line">sbox = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sbox.append(<span class="built_in">next</span>(it)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crypt_64bit_down</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x11</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        z = sbox[i] ^ x</span><br><span class="line">        x = sbox[<span class="number">0x012</span> + ((z&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>)];</span><br><span class="line">        x = sbox[<span class="number">0x112</span> + ((z&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)] + x;</span><br><span class="line">        x = sbox[<span class="number">0x212</span> + ((z&gt;&gt; <span class="number">8</span>)&amp;<span class="number">0xff</span>)] ^ x;</span><br><span class="line">        x = sbox[<span class="number">0x312</span> + ((z&gt;&gt; <span class="number">0</span>)&amp;<span class="number">0xff</span>)] + x;</span><br><span class="line">        x = y ^ x</span><br><span class="line">        y = z</span><br><span class="line">    x = x ^ sbox[<span class="number">1</span>]</span><br><span class="line">    y = y ^ sbox[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> (x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byteswap32</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span> | (a &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF0000</span> | (a &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span> | (a &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">it = struct.iter_unpack(<span class="string">&quot;&lt;I&quot;</span>, encrypted)</span><br><span class="line">encbuf = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        encbuf.append(<span class="built_in">next</span>(it)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encbuf), <span class="number">2</span>):</span><br><span class="line">    a, b = encbuf[i], encbuf[i+<span class="number">1</span>]</span><br><span class="line">    a, b = crypt_64bit_down(byteswap32(a), byteswap32(b))</span><br><span class="line">    a = byteswap32(a)</span><br><span class="line">    b = byteswap32(b)</span><br><span class="line">    encbuf[i: i+<span class="number">2</span>] = [a, b]</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encbuf), <span class="number">2</span>):</span><br><span class="line">    data += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, encbuf[i+<span class="number">1</span>])</span><br><span class="line">    data += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, encbuf[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.decode())</span><br></pre></td></tr></table></figure>

<p>至此程序逆向完成，flag成功被打印出来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了两种对开源库进行识别的方法，这种方法在逆向工程中较为重要，希望能给大家带来帮助。</p>
<h2 id="附录：对于开三次整数立方根的思考"><a href="#附录：对于开三次整数立方根的思考" class="headerlink" title="附录：对于开三次整数立方根的思考"></a>附录：对于开三次整数立方根的思考</h2><p>首先Python自己就可以开三次立方根，甚至更大的根式</p>
<p><img src="image-20211124144959385.png" alt="image-20211124144959385"></p>
<p>那么问题来了，为什么要用gmpy2这个库去开立方根，直接使用Python不就好了？</p>
<p>问题就在这里，因为Python算出来的结果不够精确，没有办法直接得到Key的值。甚至于输入0.1+0.2，Python会给出0.30000000000000004的结果（众所周知）。</p>
<p>我们试一下题目中的数字（0x74ca162812ee5cd010dacbbffa4b0d1dc82d9ca87db4e1f）开三次根式</p>
<p><img src="image-20211124145405407.png" alt="image-20211124145405407"></p>
<p>结果是一个浮点数，而我们的key是整数输入，结果肯定不相等，原因就是Python进行根式的计算不够精确。不过对于做题来讲也足够了，如果直接使用Python进行计算的话，可以将其强制转为整型再进行爆破，结果是0x4e35663063752000。而我们的正确结果的值为0x4e3566306375535f，相差并不是很大。</p>
<p><img src="image-20211124145729352.png" alt="image-20211124145729352"></p>
<p>直接爆破也可以得到正确结果。</p>
<p>但是这样的话，如果遇到非常大的数，产生很大的误差，要怎么处理呢？除了导入库之外是不是还有其他的方法去计算？</p>
<p>答案肯定是有的，不然这么多优秀的数学计算工具就不会存在了。</p>
<p>接下来介绍两种求根的算法，参考资料来自知乎<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112845185">https://zhuanlan.zhihu.com/p/112845185</a></p>
<h3 id="传统二分查找法"><a href="#传统二分查找法" class="headerlink" title="传统二分查找法"></a>传统二分查找法</h3><p>三次根式函数是在(-∞, +∞)上的连续单调函数，而我们的方程是f(x) - 0x74ca162812ee5cd010dacbbffa4b0d1dc82d9ca87db4e1f = 0</p>
<p>那么我们定义y = f(x) - 0x74ca162812ee5cd010dacbbffa4b0d1dc82d9ca87db4e1f，y在(0, n)上一定有一个根存在，那个根即为我们所要的解。</p>
<p>我们知道y函数是单调递增的，那么我们折半，然后分析这个值与我们的根式相比是大还是小，如果大了就向左边的区间(0, n/2)查找，小了就向右边的区间(n/2,n)查找，连续进行二分查找，总会一直逼近我们所要求得的根值。</p>
<p>e为精确度，如果我们的结果在精确度以内即返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cubicRoot</span>(<span class="params">n</span>) :</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = n</span><br><span class="line">    e = <span class="number">0.00000001</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>) :</span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        error = <span class="built_in">abs</span>(n - (mid * mid * mid))</span><br><span class="line">        <span class="keyword">if</span> (error &lt;= e) :</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> ((mid * mid * mid) &gt; n) :</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            start = mid</span><br></pre></td></tr></table></figure>

<p>但是这种算法对于大数的处理很不友好，例如这里如果我使用这种方法跑脚本，需要跑非常久的时间。</p>
<h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>牛顿迭代法也是一种非常棒的算法，但是很遗憾，这种算法并不可以用于计算三次根式。因为三次根式的函数如果使用牛顿迭代法是不能收敛的，如果使用牛顿迭代法只会越走越偏。</p>
<h3 id="特殊情况：三次根式整数解二分查找"><a href="#特殊情况：三次根式整数解二分查找" class="headerlink" title="特殊情况：三次根式整数解二分查找"></a>特殊情况：三次根式整数解二分查找</h3><p>既然我们知道根式的解是整数，那么我们把二分查找的范围限制在整数上，不就可以得到精确的解了吗？</p>
<p>确实是这样，如果将范围限制在整数上，那么我们就可以放弃浮点数的结果，大大减少了计算量。</p>
<p>不过这里做了一点小小的优化，将范围进行了缩小，不过hi变量的值设置为n也没有关系。</p>
<p>这种算法只能求整数解，如果放在浮点数上，结果就不是很精确了。</p>
<p>代码来自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23621833/is-cube-root-integer">https://stackoverflow.com/questions/23621833/is-cube-root-integer</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_cube_root</span>(<span class="params">n</span>):</span></span><br><span class="line">    lo = <span class="number">0</span></span><br><span class="line">    hi = <span class="number">1</span> &lt;&lt; ((n.bit_length() + <span class="number">2</span>) // <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mid**<span class="number">3</span> &lt; n:</span><br><span class="line">            lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<p>将这种算法应用在题目中：</p>
<p><img src="image-20211124152939839.png" alt="image-20211124152939839"></p>
<p>可以直接得到key的值，就不用去爆破了。</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="prog">题目</a></p>
<p><a href="prog.i64">IDB</a></p>
<p><a href="solve.py">解题脚本</a></p>

  </div>
</article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
	<div class="blog-post-comments">
        <div id="gitalk-container">
            <noscript>Your browser does not support JavaScript. Comment section is disabled.</noscript>
        </div>
    </div>
    
	<script>
		const gitalk = new Gitalk({
			clientID: 'cf9bda926b8da69d00c4', 
			clientSecret:'24aea120b771cc811e80822b3591ead2c301b0ef', 
			repo: 'blog-comment', 
			owner: 'Socular', 
			admin: ['Socular'], 
			id: location.pathname,
			distractionFreeMode: false
		})
		gitalk.render('gitalk-container')
	</script>

        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E9%80%86%E5%90%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E3%80%91-%E5%AF%B9%E5%BC%80%E6%BA%90%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%8B%E5%8A%A8%E8%AF%86%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">【逆向技巧总结】 对开源库函数的手动识别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90-BinDiff"><span class="toc-number">1.2.</span> <span class="toc-text">自动化分析 - BinDiff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">环境安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-SE-Development-Kit"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Java SE Development Kit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDA-Pro"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">IDA Pro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BinDiff"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">BinDiff</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%88%86%E6%9E%90-%E5%AF%B9%E7%85%A7%E6%BA%90%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">手动分析 - 对照源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%BC%80%E4%B8%89%E6%AC%A1%E6%95%B4%E6%95%B0%E7%AB%8B%E6%96%B9%E6%A0%B9%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">1.5.</span> <span class="toc-text">附录：对于开三次整数立方根的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">传统二分查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">牛顿迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%A0%B9%E5%BC%8F%E6%95%B4%E6%95%B0%E8%A7%A3%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.5.3.</span> <span class="toc-text">特殊情况：三次根式整数解二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">附件</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://awsl.rip/2021/11/24/239b3175dd5d/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://awsl.rip/2021/11/24/239b3175dd5d/&text=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://awsl.rip/2021/11/24/239b3175dd5d/&is_video=false&description=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【逆向技巧总结】 对开源库函数的手动识别&body=Check out this article: https://awsl.rip/2021/11/24/239b3175dd5d/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://awsl.rip/2021/11/24/239b3175dd5d/&title=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://awsl.rip/2021/11/24/239b3175dd5d/&name=【逆向技巧总结】 对开源库函数的手动识别&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://awsl.rip/2021/11/24/239b3175dd5d/&t=【逆向技巧总结】 对开源库函数的手动识别"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022
    Dominic Socular
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

		
  <script src='https://cdn.jsdelivr.net/npm/mermaid@8.4.5/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<!-- Friend Links -->

</body>
</html>
